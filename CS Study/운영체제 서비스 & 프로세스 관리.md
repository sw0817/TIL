# 운영체제(Operating System)

+++

컴퓨터를 시스템의 각종 하드웨어적인 자원과 소프트웨어적인 자원을 효율적으로 운영, 관리...

사용자가 응용 프로그램을 편리하게 사용하고 하드웨어 성능을 최적화...

**사용자가 컴퓨터 하드웨어를 몰라도 컴퓨터를 쉽게 사용할 수 있다.!**

+++



# 운영체제 서비스

> 운영체제의 주요 서비스는 하드웨어 자원(CPU, 메인 메모리, 하드디스크)을 사용자 애플리케이션에 적절히 분배해주는 것이다.
>
> 이러한 하드웨어 자원을 적절히 할당하여 컴퓨터의 성능을 최대한 효율적으로 사용해야 한다.
>
> 이를 실현하기 위해 운영체제 내에서는 각 하드웨어를 관리하는 기능을 다음과 같이 나눌 수 있다.

- 프로세스 관리
- 주기억장치 관리
- 파일 관리
- 보조기억장치 관리
- 입출력 장치 관리
- 시스템 콜

---



## 프로세스 관리

### 프로세스(Process)

> 프로세스 :  메인 메모리에서 실행 중인 프로그램
>
> 프로그램 : 어떤 작업을 위해 실행할 수 있는 파일
>
> * 프로그램은 하드디스크와 같은 보조기억 장치에 많이 있지만, 이는 아무런 동작을 하지 않는 상태이다.
> * 프로그램을 어떠한 요청에 의해 메인 메모리에 할당하여 CPU를 사용하면서 실행하게 되는데 이를 프로세스라 한다.
> * 따라서 CPU와 관련하여 프로그램 관리가 아닌 프로세스 관리라 불린다.



<img src ="https://gmlwjd9405.github.io/images/os-process-and-thread/process.png" width="600px">

#### 특징

- 프로세스는 각각의 독립된 메모리 영역(`* Code / Data / Stack / Heap`)을 할당 받는다.

- 프로세스는 최소 1개의 `*스레드`를 가지고 있다.

- 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

+++

### * Code / Data / Stack / Heap

> 프로그램이 운영체제로 부터 할당받는 메모리 공간

<img src="https://goodgid.github.io/assets/img/posts/memory_structure_1.png" width="300px">

1 ) Code 영역

- 코드 자체를 구성하는 메모리 영역
- 프로그램 명령이 위치하는 곳



2) Data 영역

- 전역변수, 배열, 구조체 등이 저장되는 메모리 영역
- 프로그램이 실행될 때 생성되고, 프로그램이 종료 되면 OS에 반환된다.



3) Stack 영역

- 프로그램이 자동으로 사용하는 임시 메모리 영역
- 지역변수, 리턴 값 등 잠시 사용되었다가, 사라지는 데이터를 저장하는 영역
- 함수 호출 시 생성되고, 함수가 끝나면 OS에 반환된다.



4) Heap 영역

- 동적 데이터 영역
  - 참고 : C, C++은 `malloc`함수를 이용해서 동적 할당 가능
  - python은 동적 할당 기능이 없다. 즉, 사용자가 직접 메모리 할당범위를 조정하지 않는다.
    - python은 자동으로 메모리를 관리해준다.

+++

### * 스레드(Thread)

> 스레드 : 하나의 프로세스 내에서 실행되는 하나 또는 여러 개의 작업 단위
>
> 스레드는 실행의 단위이다.
>
> 프로세스의 실행 = 스레드의 흐름



<img src="https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png" width="500px">

#### 특징

- 스레드는 프로세스 내에서 Stack만 할당받고, Code / Data / Heap 영역은 공유한다.

  - 왜 Stack은 독립적으로 할당할까?

    - Stack이란 함수 호출 시 전달되는 인자, 함수 내의 변수 등을 저장하기 위해 사용되는 메모리 공간

      따라서 스레드의 Stack이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고,

      이는 독립적인 실행 흐름이 추가되는 것이다.

      결과적으로 실행 흐름의 추가를 위한 최소 조건이 독립된 Stack을 제공하는 것이다.

      

  - Code / Data / Heap 영역의 공유?

    - Code
      - 프로세스는 독립적인 구조 -> 다른 프로세스의 Code 영역 함수를 호출 할 수 없다.
      - 프로그램 명령이 위치하는 곳 -> 두 개 이상의 스레드가 자신이 위치한 프로세스 Code 영역 함수 이용 가능
    - Data / Heap
      - 스레드간 통신 가능



#### 스레드 환경

1. 싱글 스레드 환경 : 하나의 프로세스 내에 하나의 스레드가 존재 (굳이 구분을 하지 않음)

   

2. 멀티 스레드 환경 : 하나의 프로세스 내에 두 개 이상의 스레드가 존재

<img src="https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png" width="700px">

- 하나의 프로세스 내의 여러 스레드들은 프로세스에게 할당된 자원을 공유한다.



왜 멀티 프로세스 대신 멀티 스레드를 사용할까?

- 프로그램을 여러 개 키지 않고, 하나의 프로그램 안에서 여러 작업을 하기 위함

1. 자원의 효율성 증대
   - 자원을 할당하는 시스템 콜이 줄어들고, 메모리를 공유하기 때문에 스레드간 데이터를 주고 받는 것이 간단해진다.
2.  처리 비용 감소
   - 프로세스 간 IPC보다 스레드 간 통신 비용이 적다.
     - Stack 영역을 제외한 다른 영역을 공유하기 때문이다.



+++

### 주요 기능

1. 프로세스를 생성(creation)하거나 소멸(deletion)

   

2. 스레드 스케줄링

   

3. 프로세스 간 통신( Interprocess Communication: IPC )

   - 프로세스 특징 中 다른 프로세스에 접근 불가능
     - 파이프, 소켓 등을 이용한 통신 방법으로 다른 프로세스 자원에 접근 가능하다.

   

4. 프로세스간 동기화

   > 현대 컴퓨터의 메모리에는 여러 프로세스가 존재한다.

   

   | 프로세스          |                             의미                             |                      예시 |
   | :---------------- | :----------------------------------------------------------: | ------------------------: |
   | **독립 프로세스** | 다른 프로세스에 영향을 주지 않거나<br/>다른 프로세스의 영향을 받지 않으면서 수행하는 프로세스 |           다중 프로그래밍 |
   | **협력 프로세스** | 다른 프로세스에 영향을 주거나<br/>다른 프로세스의 영향을 받으면서 수행하는 프로세스 | 전자우편, ```영화 예매``` |



- **현대 컴퓨터 환경에는 협력 프로세스가 훨씬 많이 존재하고, 서로 영향을 미치기 때문에 동기화가 매우 중요하다.**

  

- **동기화는 여러 프로세스가 공유하는 자원의 일관성을 유지하는 것이다.**

  - 여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때, 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜야한다.

  - ```영화 예매```

    A9 좌석을 예매 -> 예매 사이트에 A9 좌석이 예약되었다고 표시 -> 다른 사람들이 A9 좌석을 예매하지 못함.

    => 동기화에 문제가 생긴다면 여러 사람이 A9 좌석을 예매하는 상황이 발생한다.



5. 교착상태 처리(deadlock handling)

> 교착상태 : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

<img src = "https://t1.daumcdn.net/cfile/tistory/27254C37580F02B632" width = "400px">

자동차(프로세스)들이 현재 위치한 길(자원)을 점유함과 동시에 다른 차가 사용하는 길을 사용하려고 대기하고 있지만, 

다른 길을 사용할 수 없으며 현재 길에서도 벗어나지 못함.



## 교착상태와 식사하는 철학자들

<img src="https://t1.daumcdn.net/cfile/tistory/253CDD4B5802FBB52A" width = "500px">



### 교착상태 필요 조건

> 네 가지 조건이 모두 해당된다고 해서 반드시 교착상태가 일어나는 것이 아닌, 일어날 가능성이 있다고 한다.
>
> 식사하는 철학자 문제에서는 네 가지 모두 해당되면 교착상태이다.

- 상호배타 : 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
  - 한 철학자(프로세스)가 포크(자원)를 사용하면 다른 철학자는 이 포크를 사용할 수 없다.



- 보유 및 대기 : 한 프로세스가 자원을 가지고 있는 상태에서 대기한다.

  - 철학자는 왼쪽 포크를 가지고 있는 상태에서 오른쪽 포크를 집기 위해 대기한다.

  

- 비선점 : 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.

  - 한 철학자가 포크를 집은 상태에서 다른 철학자가 이 포크를 뺏을 수 없다.



- 환형대기 : 프로세스가 요구하는 자원의 방향이 원형을 이룬다. (대기가 꼬리에 꼬리를 문 상황)
  - 모든 철학자는 왼쪽 포크부터 집을 수 있다.



### 교착상태 방지

> 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 하는 것.

- 상호배타 : 자원을 공유 가능하게 만든다.

  - 한 철학자가 사용하는 포크를 동시에 다른 철학자가 사용한다.(불가능)

  

- 보유 및 대기 : 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 한다.

  - 오른쪽 포크를 집을수 없을 때, 왼쪽 포크를 식탁에 내려놓는다.

    - 문제점 : 양 손 모두 포크를 잡지 못한 상태가 되므로, **자원 활용률이 저하**된다.

    

- 비선점 : 한 프로세스가 자원을 수행하는 중에 다른 프로세스가 끼어들게 한다.

  - 철학자는 포크를 빼앗을 수 없다는 조건(조건에 의한 불가능)

    

- 환형대기 : 모든 자원에 번호를 부여하여 오름차순으로 자원을 요청한다.

  - 누군가는 왼쪽이 아닌 오른쪽 포크를 먼저 집게 만든다.
    - 문제점 : **자원 활용률 저하**

---



## 주기억장치 관리

> CPU는 오직 메인 메모리에 있는 프로그램과 소통할 수 있다.
>
> 주기억장치 관리에서는 메인 메모리를 효율적으로 사용하도록 관리한다.



### 주요기능

- 프로세스에게 메모리 공간 할당

  - 주기억장치에서 여러 프로세스가 적재되어야 하는 다중프로그래밍 환경

    기억 장치의 효율성과 성능 향상을 위해 각 프로세스에 할당되는 공간의 크기를 조절해야한다.

    

1) 단일 사용자 할당 기법

> 운영체제가 차지하는 부분을 제외한 나머지 기억 공간의 부분을 사용자가 독점 사용하도록 하는 기법.
>
> 초기 운영체제에서 자주 사용

<img src="https://mblogthumb-phinf.pstatic.net/MjAxNzA1MTVfOCAg/MDAxNDk0ODU3NTg0NDI3.4xRzVFX-Mjh1CiCgP_0qeESZtY9OFd3TgQVP3HZIZ08g.Esfx-kvpPXP8n3HAe0AMKqoNLN6qXmm7R6ngtmbK5Gog.PNG.dlrmawn9813/image_5384994571494857557444.png?type=w800" width="400px">



**특징**

장점

- 사용자에게 융통성을 최대한 제공
- 최대의 단순성과 최소의 비용

단점

- 프로그램의 크기가 작을 경우 = 미 사용 영역 = 낭비



2)  고정 분할 할당 기법

> 각 프로그램에 고정된 크기의 분할된 구역을 할당하고, 준비중인 프로그램을 각 영역에 할당하여 수행

<img src="https://mblogthumb-phinf.pstatic.net/MjAxNzA1MTVfMTEx/MDAxNDk0ODU5MjQ0ODEy.zgblLZnCWk9ZhXyPr97xXM25QB8DUUfJ4J3xTJVd0DIg.v4lXLOgtGG3ZdIdA0akTr0B7MATQNsc6sIgINdVXRFQg.PNG.dlrmawn9813/image_114692611494859225053.png?type=w800" width="">

작업 2는 크기가 일치하는 분할 2에 들어가고, 미 사용 영역이 없다.

하지만 작업 1, 3은 할당 후 미사용 영역이 생기고,

작업 4는 할당 조차 되지 못한다.



**그렇다면, 분할 크기를 재조정 하면 되지 않을까?**

고정 분할 할당 기법은 운영체제를 생성할 때 설정되어 변경될 수 없다. = **문제점 발생!!**

- 내부 단편화 발생
  - 프로세스 크기와 메모리의 고정 분할된 크기가 다를 가능성이 크므로 비어 있는 공간이 발생한다.
    - 분할 크기 - 프로세스 크기 = 내부 단편화 (ㄴ / ㄷ)
- 외부 단편화 발생
  - 프로세스의 크기가 분할 크기보다 커서 분할 전체가 빈 공간으로 있을 수 있다. = 외부 단편화 ( ㄱ )

+++



- 메모리의 어느 부분이 어느 프로세스에 할당되었는가 추적 및 감시



- 프로세스 종료 시 메모리 회수

  - 다른 프로세스에 나눠주어야 하기 때문

  

- 메모리의 효과적인 사용

  - 메모리 관리를 못하면 빈 메모리도 사용할 수 없게 된다.

  

- 가상 메모리 : 물리적 실제 메모리보다 큰 용량을 사용할 수 있다.

  - 일반적으로 메인 메모리(많아야 수 기가바이트)는 보조기억장치(수백 기가 바이트~)에 비해 용량이 작다.

---



## 파일 관리

> 물리적으로 Track , Sector, Head로 구성된 디스크... OS는 사용자에게 **물리적**이 아닌 **논리적** 관점(파일)으로 데이터를 보게 해준다.
>
> 파일이라는 논리적 형태로 운영체제에서 관리하고 보여주기 때문에 사용자는 쉽게 사용할 수 있다.



### 주요 기능

- 파일의 생성과 삭제



- 디렉토리의 생성과 삭제

  > 디렉토리 ㅣ 윈도우 환경에서는 폴더를 의미

  

- 파일에 대한 기본 동작 지원 : open, close, read, write



- 백업



---

## 보조기억장치 관리

> 하드디스크, 플래시 메모리, SSD 등이 있다.
>



### 주요기능

- 빈 공간 관리



- 저장공간 할당



- 디스크 스케줄링

  - 보조기억장치에 있는 데이터에 접근하기 위해 디스크 헤드가 움직이는 경로를 결정하는 기법

    

    <img src="https://t1.daumcdn.net/cfile/tistory/99A3C44B5B3B06DD04" width="400px"/>

    

    <img src="https://t1.daumcdn.net/cfile/tistory/99DB3D4D5B3B06FA3A" width="400px">

    > Head : 플래터 위 아래에 존재하며, 플래터 표면을 움직이며 데이터를 쓰거나 읽어온다.
    >
    > Track : 플래터 표면에 데이터가 저장된 공간
    >
    > Sector : Track의 일부 (가장 작은 단위)

    

    디스크 스케줄링 종류

    - First Come First Served(FCFS) 스케줄링 : 요청이 들어온 순서대로 처리(비선점 스케줄링)

    | 현재 헤드 위치 |           요청 대기열            |
    | :------------: | :------------------------------: |
    |       50       | 100 180 40 120 130 70 80 150 200 |

    |                          이동 순서                           |
    | :----------------------------------------------------------: |
    |             50 100 180 40 120 130 70 80 150 200              |
    | 이동거리 = 50 + 80 + 140 + 80 + 10 + 60 + 10 + 70 + 50 = 550 |

    장점 : 요청 순서대로 서비스 하기 때문에 공평하다

    단점 : 주요 프로세스 수행이 늦어질 수 있다.

    

    

    - Shortest Seek Time First(SSTF) 스케줄링 : 현재 헤드 위치에서 가장 가까운 거리 트랙으로 헤드 이동

    | 현재 헤드 위치 |           요청 대기열            |
    | :------------: | :------------------------------: |
    |       50       | 100 180 40 120 130 70 80 150 200 |

    |                          이동 순서                          |
    | :---------------------------------------------------------: |
    |             50 40 70 80 100 120 130 150 180 200             |
    | 이동거리 = 10 + 30 + 10 + 20 + 20 + 10 + 20 + 30 + 20 = 170 |

    장점 : 처리량 많은 일괄처리 시스템에 유용

    단점 : 서비스한 트랙에서 가까운 트랙에 대한 서비스 요청 계속 발생 - 먼거리 트랙 서비스 무한정 대기 상태

    

    - SCAN, C-SCAN ...

  

---

## 입출력 장치 관리

> 입출력 장치에는 키보드, 마우스, 스피커 등이 있다.



### 주요 기능

- 장치 드라이브 관리

- 입출력 장치의 성능 향상
  - buffering : 입출력 장치에서 읽는 내용을 메모리로 들고온다. -> 이후에는 빠르게 읽을 수 있다.
  - caching
  - spooling : 입출력장치와 CPU 간의 처리속도 차이로 인한 대기시간을 줄이기 위한 기법 
    - 프린터(처리 속도가 느림)로 글자를 찍을 동안 CPU(처리 속도가 빠름)가 기다리면 너무 늦기 때문에, 처리속도가 프린터보다는 빠르고 CPU보다는 느린 디스크에 일시적으로 저장한다. 이후 디스크에 저장된 내용을 천천히 프린터에 보내기 때문에 그 사이에 CPU는 다른 작업을 할 수 있다.

  

  `TMI`

  프린터가 안될 때? = 프린터 스풀링 인쇄 오류 의심

- 경로 : 로컬디스크(C:) - Windows - System32 - spool - PRINTERS

- PRINTERS 폴더에 파일들이 있으면 인쇄 오류 가능성 有

  

---

## 시스템 콜

> OS는 다양한 서비스들을 수행하기 위해 하드웨어를 직접적으로 관리한다.
>
> OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다.
>
> OS가 제공하는 이러한 인터페이스를 시스템 콜 이라고 한다.



<img src="https://i.imgur.com/YINBipo.png " width="600px">  



### 시스템 콜 동작

+++



<img src="https://i.imgur.com/UH0DDZt.png" width="500px">

> user mode : 사용자가 접근할 수 있는 영역 제한 / 코드를 작성
>
> kerner mode : 모든 자원(드라이버, 메모리, CPU)에 접근, 명령 가능



1) `printf()` 함수 실행 : user mode에서 수행되어 stdio 라이브러리 호출

2) stdio 라이브러리 : 시스템 콜인 `write()` 함수를 호출하고 kerner mode로 전환

3) kerner은 호출을 실행하여 모니터에 문자열 출력

4) 다시 user mode로 전환 - `printf()` 함수 다음 단계 진행



### 주요 시스템 콜

- Process : 

  - end : 정상 종료
  - abort : 강제 종료
  - load : 하드 디스크에 있는 프로그램을 메인 메모리로 가져오는 것
  - execute : 실행
  - create : 프로세스를 생성
  - terminate : end와 같음
  - get / set attributes : 프로세스 속성 (메모리를 얼마나 사용하는가 ...)
  - wait event
  - signal event

  

- Memory : 
  - allocate : 프로그램이 돌수록 메모리가 필요하기 때문에 OS에 메모리 요청
  - free : 메모리를 다 쓰면 되돌려 줌



- File :
  - create
  - delete
  - open
  - close
  - read, write
  - get/set attributes



- Device : 
  - request
  - release
  - read, write
  - get/set attributes
  - attach/detach devices



- information : 
  - get/set time
  - get/set system data



- Communication : 
  - socket
  - send
  - receive
  
  

+++

**참고** (Ctrl + Click)



운영체제 쉽게 알아보자! : https://jhnyang.tistory.com/16

프로세스 간 통신의 종류를 알아보자! : https://doitnow-man.tistory.com/110

[IT 기술면접 준비자료] 교착상태와 식사하는 철학자들 : https://preamtree.tistory.com/18

디스크 스케줄링의 다양한 방법들 : https://limkydev.tistory.com/165

프린터 스풀링 오류를 해결해보자! : http://blog.naver.com/PostView.nhn?blogId=juwon5642&logNo=221422525079

시스템 콜 : https://luckyyowu.tistory.com/133

시스템 콜의 다양한 레퍼런스 : https://whitesnake1004.tistory.com/2

+++


